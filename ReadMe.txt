For my implementation of Klondike Solitaire, I incorporated several design patterns. I used the Flyweight pattern for card images, where each card suit/rank image is loaded once and shared among all instances. My cardImages table in the Game class works as a flyweight pool, storing one image per card type, which significantly reduces memory usage as I only store 52 unique card images rather than duplicating them.
I also implemented the Prototype pattern through my Card class, which serves as a template where new cards are created using the Card:new() method. This allowed me to create cards consistently with standardized behaviors, while individual instances maintain their own state. I also used the State pattern for cards, where each card has a state (face up or down) that affects its behavior and appearance. 
Sequencing Patterns
For game sequencing, I relied on LÃ–VE2D's built-in Game Loop functions: love.load(), love.update(), and love.draw(). This provided the core structure for my game's execution flow. I also implemented the Update Method pattern in my Game:updateCardPositions() method to refresh all card positions after any game state change, ensuring all objects are properly positioned for rendering.
Behavioral Patterns
In terms of behavioral patterns, I used the Type Object pattern for card ranking and suit systems. My RANK_VALUES, RED_SUITS and BLACK_SUITS tables in the Card class define card characteristics and behaviors based on their type, allowing me to easily check conditions like card color and valid moves.
Decoupling Patterns
I structured my game using the Component pattern, creating separate components (Card, Vector, Grabber, Game) that handle specific responsibilities. My Grabber component manages all drag-and-drop interactions, while my Vector component handles mathematical operations, providing reusable functionality across the project.
Postmortem
Looking back at my project, there are several aspects I feel went particularly well. Breaking up the code into logical modules (Card, Vector, Grabber, Game) made my work much more readable. The refactoring of the Grabber class into smaller functions was especially successful, improving readability and maintainability of what could have been a complex part of the code. Creating a reusable Vector class also simplified position and collision detection logic, reducing redundancy throughout my code.
I'm particularly pleased with my decision to sum up card behavior within the Card class (isRed, isBlack, canStackOnTableau, canAddToFoundation), which made game rules easier to implement and modify. This object-oriented approach allowed me to think about cards as entities with their own behaviors rather than just data structures.
If I were to do this project over again, there are several improvements I would make. I would implement the Command pattern for moves to enable undo/redo functionality, which would significantly improve player experience. An Observer pattern could have been used to notify components of game state changes, reducing direct dependencies between components. I would also implement a formal State pattern to manage game states more explicitly.
For more complex animations, I would consider implementing a Double Buffer pattern to provide smoother visual transitions. I would also add features like score tracking, a timer, game statistics, multiple card back styles, and animations for card movements to make the game more engaging and polished.
Assets Used
For my implementation, I used Kenney's Playing Cards Pack (https://kenney.nl/assets/playing-cards-pack) for the card images, which provided a clean and professional look for the game. I adapted the Fisher-Yates Shuffle Algorithm (https://www.geeksforgeeks.org/shuffle-a-given-array-using-fisher-yates-shuffle-algorithm/) for my card shuffling functionality to ensure a truly random distribution.

